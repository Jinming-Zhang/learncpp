# RNG
Because a deternimistic algorithm will produce the same result with identical input, a purely deterministic algorithm can not generate truely randomized numbers, most of the time it's called `pseudo-random number generator` (PRNG).

# What makes a good PRNG
 -   `uniform distribution`: The PRNG should generate each number with approximately the same probability.
 - `unpredictibility`: The method by which the next number will be generated shouldn't be predictable.
 - `uniform dimensional distribution`: The PRNG should have a good dimensional distribution of numbers. (i.e. not random large number first then random small numbers after)
 - `high period`: The PRNG should have a high period for all seeds.
 
 # Random Numbers Mapping
 Often we only want random numbers in a certain range. It's worth noticing that it is also important to map the *number spacd* of a PRNG to our desired *number space * **univormly**.
 
`std::uniform_int_distribution` is a function that can map a set of numbers to another set of numbers uniformly.
```cpp
// Create a reusable random number generator that generates uniform numbers between 1 and 6
	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };
```
# Seeds
An RNG's job is to make a sequence of numbers as best as it can. 
Since it's deterministic, to make it produce different sequence of "random" numbers each time, we need to provide it a different seed.

>CAREFUL:
>Only set the seed for a RNG **once**.

This is because a good RNG already handles the part of generating a sequence of random numbers with a given seed.
If we initialize a RNG with "less randomized" seeds multiple times, the result can be **worse** than the random numbers generated by the RNG from a single seed.
The "less randomized" seeds we used actually make the result less randomized.

# Good Seed Resources
### System Clock
Use time as a seed.

```cpp
#include <iostream>
#include <random> // for std::mt19937
#include <chrono> // for std::chrono

int main()
{
	// Seed our Mersenne Twister using the
	std::mt19937 mt{ static_cast<unsigned int>(
		std::chrono::steady_clock::now().time_since_epoch().count()
		) };

	// Create a reusable random number generator that generates uniform numbers between 1 and 6
	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };

	// Print a bunch of random numbers
	for (int count{ 1 }; count <= 40; ++count)
	{
		std::cout << die6(mt) << '\t'; // generate a roll of the die here

		// If we've printed 10 numbers, start a new row
		if (count % 10 == 0)
			std::cout << '\n';
	}

	return 0;
}
```
### Random Device from OS
Often operating systems have implementation-defined PRNG which involves which take some environmental randomness into account, such as physical noises.

This can be a good source to use as a seed to a RNG. (make sure it doesn't have bug on official compiler's site)


```cpp
#include <iostream>
#include <random> // for std::mt19937 and std::random_device

int main()
{
	std::mt19937 mt{ std::random_device{}() };

	// Create a reusable random number generator that generates uniform numbers between 1 and 6
	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };

	// Print a bunch of random numbers
	for (int count{ 1 }; count <= 40; ++count)
	{
		std::cout << die6(mt) << '\t'; // generate a roll of the die here

		// If we've printed 10 numbers, start a new row
		if (count % 10 == 0)
			std::cout << '\n';
	}

	return 0;
}
```
